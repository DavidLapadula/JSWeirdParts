- Syntax Parsers
     - parser to determine if your code grammar is valid
     - ensure compiler/interpreter can read code properly and convert to instructions
     - interpreter can do additional things with your code before instructions are made
- Lexical Environments
    - where something is in your code. place of what you write is important
    - where its written will determine where it sits in memory after it is compiled
- Execution Context
    - wrapper to manage the code you are running
    - which lexical environment is actually running managed by execution context
- Name/Value pair
    - name which maps to unique value. name can only have 1 value in any execution context
    - value can be more more collections
    - Object in JS is collection of name/value pairs
- Code in JS always run in execution context. Base execution context is global context
    - Global context means accessible available anywhere. Creates global object and 'this'
- JS engine creates various execution context to run code
- Hoisting
    - vars and functions available before they are written
    - Limited access to these values before they are defined
    - Execution ctx created in 2 phases
        - Creation phase: duing this parser sets up memory for vars and fn's. BEFORE your code executes, memory made available for vars/fn's you made. Doesn't know value of vars until execution ctx
            - Fn's sit in memory as is but variables are created as undefined
        - Execution phase: where assignments are set and run code (interpret -> compile -> run)
- undefined
    - special js value for things that have not been set
    - value var receives during creaaton phase when creating execution cts
    - undefined should mean "code was never set" so never explicity set it, let js engine do that
- Single threaded: one command at a time
- Synchronous: one command at a time and IN ORDER